<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>07: Sample Processing</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">07: Sample Processing</h1>



<div id="overview" class="section level2">
<h2>Overview</h2>
<p>In the first series of vignettes, we worked with high-level wrapper
functions like <code>age_standardize()</code>,
<code>suppress_estimates()</code>, and <code>get_estimates()</code>. In
this vignette, we will be working with the functions that underlie these
wrappers and manually generating our estimates, unlocking the more
powerful capabilities of RSTr.</p>
<p>Before we begin, note that the above functions make direct changes to
our <code>RSTr</code> model object. We can manually save our estimates
to the model object, but these estimates will not be automatically
added. In exchange for more power with sample processing, we lose some
of the convenience afforded to us by these wrapper functions.</p>
</div>
<div id="the-load_samples-function" class="section level2">
<h2>The <code>load_samples()</code> function</h2>
<p>To begin, let’s generate samples for a new model:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>mod_mst <span class="ot">&lt;-</span> <span class="fu">mstcar</span>(<span class="at">name =</span> <span class="st">&quot;my_test_model&quot;</span>, <span class="at">data =</span> miheart, <span class="at">adjacency =</span> miadj, <span class="at">seed =</span> <span class="dv">1234</span>)</span></code></pre></div>
<p>Once <code>mstcar()</code> tells you that the model is finished
running, you can import samples into R using
<code>load_samples()</code>. <code>load_samples()</code> takes in four
arguments:</p>
<ul>
<li><p><code>RSTr_obj</code>: Our <code>RSTr</code> model
object;</p></li>
<li><p><code>param</code>: The parameter to import samples for;
and</p></li>
<li><p><code>burn</code>: Specifies a burn-in period for samples. This
allows the model time to stabilize before using samples to generate
estimates. By default, has a burn-in period of 2000 samples.</p></li>
</ul>
<p>Any <code>dimnames</code> that were saved to <code>data</code> will
be applied to the samples as appropriate. Here, we pull in the
<code>lambda</code> samples for our test Michigan dataset with a
2000-sample burn-in period (as specified by the default arguments). We
also multiply by 100,000 as it is common to display mortality rates per
100,000 individuals:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">load_samples</span>(mod_mst, <span class="at">param =</span> <span class="st">&quot;lambda&quot;</span>, <span class="at">burn =</span> <span class="dv">2000</span>) <span class="sc">*</span> <span class="fl">1e5</span></span></code></pre></div>
<div id="group-aggregation" class="section level3">
<h3>Group aggregation</h3>
<p>In many cases, we will want to aggregate our data across non-age
groups, such as when looking at prevalence estimates or to simply
consolidate our non-age sociodemographic groups. In our Michigan
dataset, we have 10 years of data over which we can consolidate to look
at prevalence. In these cases, we need to pull in the population array
as a weight. First, we need to check which margin contains our year
information using the <code>dim()</code> function:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">dim</span>(samples)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="co">#&gt; [1] 83  6  3 20</span></span></code></pre></div>
<p>Our <code>samples</code> array has four margins with dimensions
<code>83</code>, <code>6</code>, <code>10</code>, and <code>400</code>,
representing the spatial regions, age groups, time periods, and
iterations, respectively. Let’s set a variable <code>margin_time</code>
to represent our time period margin and aggregate our
<code>samples</code> estimates across 1988-1988 using the
<code>aggregate_samples()</code> function. The population data needed to
weight our samples can be pulled from our <code>RSTr</code> model
object:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>margin_time <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>pop <span class="ot">&lt;-</span> mod_mst<span class="sc">$</span>data<span class="sc">$</span>n</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>samples_7988 <span class="ot">&lt;-</span> <span class="fu">aggregate_samples</span>(samples, pop, margin_time)</span></code></pre></div>
<p>Now, we have a standalone sample array for our 1988-1988 samples. But
what if we are interested in both the individual year data <em>and</em>
the prevalence data? We can alternatively bind these new samples to our
main <code>samples</code> array by adding in values for the
<code>bind_new</code> and <code>new_name</code> arguments:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">aggregate_samples</span>(samples, pop, margin_time, <span class="at">bind_new =</span> <span class="cn">TRUE</span>, <span class="at">new_name =</span> <span class="st">&quot;1979-1988&quot;</span>)</span></code></pre></div>
<p>Group-aggregation is a feature unique to only samples;
group-aggregation cannot be performed on model objects.</p>
</div>
<div id="age-standardization" class="section level3">
<h3>Age-standardization</h3>
<p>The process of age-standardization is similar to that of
group-aggregation, but requires a bit more nuance in its use. We can
also use our samples to age-standardize these into a 35-64 group. Like
before, since we are using data from 1988-1988, we can use 1980 standard
populations from <a href="https://seer.cancer.gov/stdpopulations/stdpop.19ages.html">NIH</a>
to generate a <code>std_pop</code> vector:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>age <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;45-54&quot;</span>, <span class="st">&quot;55-64&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>std_pop <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">113154</span>, <span class="dv">100640</span>, <span class="dv">95799</span>)</span></code></pre></div>
<p>With <code>std_pop</code> generated, we need to then check which
margin contains our age group information using the <code>dim()</code>
function:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">dim</span>(samples)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt; [1] 83  6  4 20</span></span></code></pre></div>
<p>Our age groups lay along the second margin. Let’s set a variable
<code>margin_age</code> and standardize our <code>samples</code>
estimates across ages 35-64 using the <code>standardize_samples()</code>
function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>margin_age <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>groups <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;45-54&quot;</span>, <span class="st">&quot;55-64&quot;</span>)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>samples_3564 <span class="ot">&lt;-</span> <span class="fu">standardize_samples</span>(samples, std_pop, margin_age, groups)</span></code></pre></div>
<p>Note that there may be times where you have groups stratified by both
age and other sociodemographic groups. In these cases, you’ll have to
refactor your sample array so that the age groups are separated from
your other groups before doing age-standardization using
<code>split_sample_groups()</code>.</p>
<p>Now, we have a standalone array for our age-standardized 35-64 age
group. Similarly to <code>aggregate_samples()</code>, we can
alternatively consolidate this into our main <code>samples</code> array
by adding in values for the <code>bind_new</code> and
<code>new_name</code> arguments:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">standardize_samples</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  samples,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  std_pop,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  margin_age,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  groups,</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>  <span class="at">bind_new =</span> <span class="cn">TRUE</span>,</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>  <span class="at">new_name =</span> <span class="st">&quot;35-64&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>)</span></code></pre></div>
<p>Now, our samples for <code>samples</code> are aggregated by year and
age-standardized, and we have matching array values for
<code>pop</code>. Note that if you plan on doing a mix of non-age
aggregation and age-standardization, do age-standardization
<em>after</em> aggregation, as doing age-standardization first will
alter the results of any aggregation done afterward.</p>
</div>
</div>
<div id="estimates-and-reliability" class="section level2">
<h2>Estimates and Reliability</h2>
<p>To get our medians, we simply put our samples into get_medians():</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>medians <span class="ot">&lt;-</span> <span class="fu">get_medians</span>(samples)</span></code></pre></div>
<p>Let’s get some reliability metrics for our dataset. First, let’s
generate our relative precisions at 95% credibility using the
<code>get_credible_interval()</code> and
<code>get_relative_precision()</code> functions, then create a
<code>logical</code> <code>array</code> that tells us which estimates
are unreliable:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>ci <span class="ot">&lt;-</span> <span class="fu">get_credible_interval</span>(<span class="at">sample =</span> samples, <span class="at">perc_ci =</span> <span class="fl">0.95</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>rel_prec <span class="ot">&lt;-</span> <span class="fu">get_relative_precision</span>(medians, ci)</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>low_rel_prec <span class="ot">&lt;-</span> rel_prec <span class="sc">&lt;</span> <span class="dv">1</span></span></code></pre></div>
<p>Now, let’s generate a similar <code>logical</code> <code>array</code>
for populations less than 1000 and use these criteria to create a set of
suppressed medians. A median will be suppressed if it meets either of
the two criteria. Note that since our samples are age-standardized, we
also have to extend our <code>pop</code> array to match in size using
the <code>aggregate_count()</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>pop <span class="ot">&lt;-</span> <span class="fu">aggregate_count</span>(pop, margin_age, <span class="at">groups =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">bind_new =</span> <span class="cn">TRUE</span>, <span class="at">new_name =</span> <span class="st">&quot;35-64&quot;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>pop <span class="ot">&lt;-</span> <span class="fu">aggregate_count</span>(pop, margin_time, <span class="at">bind_new =</span> <span class="cn">TRUE</span>, <span class="at">new_name =</span> <span class="st">&quot;1988-1988&quot;</span>)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>low_population <span class="ot">&lt;-</span> pop <span class="sc">&lt;</span> <span class="dv">1000</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>medians_supp <span class="ot">&lt;-</span> medians</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>medians_supp[low_rel_prec <span class="sc">|</span> low_population] <span class="ot">&lt;-</span> <span class="cn">NA</span></span></code></pre></div>
<p>Let’s now map our suppressed estimates:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>est_3544 <span class="ot">&lt;-</span> medians_supp[, <span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;1988&quot;</span>]</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="fu">ggplot</span>(mishp) <span class="sc">+</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="fu">aes</span>(<span class="at">fill =</span> est_3544)) <span class="sc">+</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">&quot;Smoothed Myocardial Infarction Death Rates in MI, Ages 35-44, 1988&quot;</span>,</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">&quot;Deaths per 100,000&quot;</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>  <span class="fu">scale_fill_viridis_c</span>() <span class="sc">+</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>  <span class="fu">theme_void</span>()</span></code></pre></div>
<pre><code>#&gt; NULL</code></pre>
<p>With our samples available, we can generate estimates from different
credible intervals without having to re-run the model:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>ci <span class="ot">&lt;-</span> <span class="fu">get_credible_interval</span>(samples, <span class="fl">0.995</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>rel_prec50 <span class="ot">&lt;-</span> <span class="fu">get_relative_precision</span>(medians, ci)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>low_rel_prec <span class="ot">&lt;-</span> rel_prec50 <span class="sc">&lt;</span> <span class="dv">1</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>medians_supp <span class="ot">&lt;-</span> medians</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>medians_supp[low_rel_prec <span class="sc">|</span> low_population] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>est_3544 <span class="ot">&lt;-</span> medians_supp[, <span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;1988&quot;</span>]</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="fu">ggplot</span>(mishp) <span class="sc">+</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="fu">aes</span>(<span class="at">fill =</span> est_3544)) <span class="sc">+</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">&quot;Smoothed Myocardial Infarction Death Rates in MI, 99.5% CI, Ages 35-44, 1988&quot;</span>,</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">&quot;Deaths per 100,000&quot;</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>  <span class="fu">scale_fill_viridis_c</span>() <span class="sc">+</span></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>  <span class="fu">theme_void</span>()</span></code></pre></div>
<pre><code>#&gt; NULL</code></pre>
<p>We can even use these samples to learn more about our data. Let’s say
we are interested in figuring out if a rate estimate is statistically
significantly greater than or less than the overall state rate. We can
calculate a crude state rate for our 35-44 age group, then compare that
against our samples. Note that we can make statistical significance
comparisons, even if our rates are unreliable:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>crude_3544 <span class="ot">&lt;-</span> <span class="fu">sum</span>(mod_mst<span class="sc">$</span>data<span class="sc">$</span>Y[, <span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;1988&quot;</span>]) <span class="sc">/</span> <span class="fu">sum</span>(mod_mst<span class="sc">$</span>data<span class="sc">$</span>n[, <span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;1988&quot;</span>]) <span class="sc">*</span> <span class="fl">1e5</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>sample_3544 <span class="ot">&lt;-</span> samples[, <span class="st">&quot;35-44&quot;</span>, <span class="st">&quot;1988&quot;</span>, ]</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>p_higher <span class="ot">&lt;-</span> <span class="fu">apply</span>(sample_3544, <span class="dv">1</span>, \(county) <span class="fu">mean</span>(county <span class="sc">&gt;</span> crude_3544)) <span class="sc">*</span> <span class="dv">100</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="fu">ggplot</span>(mishp) <span class="sc">+</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>  <span class="fu">geom_sf</span>(<span class="fu">aes</span>(<span class="at">fill =</span> p_higher)) <span class="sc">+</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">&quot;Probability that County Rate &gt; State Rate MI, Ages 35-44, 1988&quot;</span>,</span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">&quot;Probability&quot;</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>  <span class="fu">scale_fill_continuous</span>(<span class="at">palette =</span> <span class="st">&quot;RdBu&quot;</span>, <span class="at">trans =</span> <span class="st">&quot;reverse&quot;</span>) <span class="sc">+</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>  <span class="fu">theme_void</span>()</span></code></pre></div>
<pre><code>#&gt; NULL</code></pre>
<p>On this map, we can see that much of the northern Lower Peninsula is
significantly lower than the state rate, whereas the southern portion of
the LP has many places with significantly higher rates. The western
Upper Peninsula also shows areas of significantly higher rates.</p>
</div>
<div id="closing-thoughts" class="section level2">
<h2>Closing Thoughts</h2>
<p>In this vignette, we discussed features unique to sample processing
like <code>aggregate_samples()</code>, more granual control over our
samples, and extensions of our analysis using samples.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
